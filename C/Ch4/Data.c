/*
* 작성일	: 2025.02.20
* 작성자	: 김강석
* 주제	: 데이터 표현 방식
*/

/*
* 2가지의 타입 : 정수, 실수, +문자(숫자)
* int, char, short, long, longlong - 정수
* float, double, decimal - 실수
* 
* (사람 - 사람) (컴퓨터 - 사람) int 어떻게 이해를 할까?
* int 변수이름; 변수이름 녀석이 정수현태의 값을 받을 수 있다. + 데이터 저장 크기를 저장
*/


/*
* 정수를 표현하는 방법
* - 표현하는 키워드가 많다.
* - 이유 : 최선의 메모리를 사용하기 위해서
* - 컴퓨터의 정보를 읽는 기본 단위 : 바이트
* - 비트 ㅁ(0,1)
* 
* char, short, int
* 10진수 2진수
* 16		0000 1000 = 2^4X1	2^8=256
* 127		00000000(2)
*			00111111
*/

/*
* 뺄셈 : A-B		A+(-B)
* 정수 : 음수를 표현하는 방법
* MSB : Most Signmant Bit
* 데이터 표현방식에서 가장 왼쪽 끝에 이쓴 비트에 할당한다.
* 
* 5 양수		00000101 2^2 *1 + 2^0 *1 = 4 + 1 = 5
* -5 비트로 어떻게 표현할까?
* 
* 2의 보수법 - 양수를 비트로 표현합니다. 모든 비트를 반전시킨다 +1;
*				00000101
*				10000101
*				11111111
*				       1
*			 1	00000000
* 5 + (-5) = 0
* 
* 메모리 측면.
* unsigned bit
*/

/*
* 실수를 표현하는 방식
* 2바이트		00000000 00000000
* 8 8 (절반은 정수, 절반은 실수)
* 00000101 00000101 -> 5.5
* 
* 5.4955 // 표현하고자 하는 수가 얼마 차이가 나지 않는다. 실수를 표현하는 비트의 수가 너무 적다.
* 실수를 표현할 수 있는 범위가 너무 적다.
* 
* 부동소수점 방식 : float 둥둥 떠다니다.
* 
* 125.234091
* 
* (정수) * 정규화된식^(지수)
* 어떤 수를 제곱, 1;
* 33^0 = 1
* 0
* 
* 수를 0 < 10 사이의 수로 표현합니다.
* 0.2334
* 
* 부동소수점의 오차가 발생한다.
* 1 = 1.0 컴퓨터에서는 다르다.
*/

/*
* int attackPower = 10 + 1 * 0.3;
* 리터럴 상수
* int, double - int 형 정의, double 형 정의
* 1 * 0.3;
* int 정의 => 0
* double 정의 => 0.3
* 반드시 손실이 발생 -  . -> 날아간다.
* 이유 -> double 11 + 0.3
*/

/*
* 데이터 형 -> 스스로 형태를 바꾸고 있다.
* 형 변환
* - 자동 : 묵시적 변환
* - 수동 : 명시적 변환
*/

#include <stdio.h>

int main()
{
	int attackPower = 10 + 1 * 0.3;	// 10
	double attackPower2 = 10 + 1 * 0.3;

	printf("값 : %d\n", attackPower);
	printf("값 : %lf\n", attackPower2);

	printf("정수의 표현 방식 실습\n");

	char num1 = 129+60;		// 0000 0000
							// 0111 1111 127
							// 1000 0001
	int num2 = 129;			// ( ) ( ) ( ) 1000 0001	111 1111 = -127
	char num3 = num2;
	printf("값 : %d\n", num1);
}